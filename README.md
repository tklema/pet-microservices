# Простое микросервисное приложение с тестами, docker-compose и CI/CD


## Описание

1. Пользовательский сервис (user-service) с поддержкой:
- Создания пользователя
- Удаления пользователя
- Получения полной информации о пользователе
- Просмотр всех пользователей

2. Сервис заказов (order-service) с поддержкой:
- Создания заказа с привязкой к пользователю
- Удаления заказа
- Получения полной информации о заказе
- Получения всех заказов пользователя

## Технологии

- Java 17
- Maven
- Spring Boot 3.5.4
- Spring Web
- Spring Data JPA
- Spring Cloud OpenFeign
- Spring Validation
- Spring Actuator
- Spring Boot Test
- Spring Boot Maven Plugin
- H2 Database
- Lombok
- JUnit 5
- Mockito
- Docker
- Docker Compose
- GitHub Actions

## Запуск приложения

Можно запустить как через командную строку, так и через docker-compose

### Запуск через командную строку

Запустить оба сервера по отдельности, выполнив в каждой дериктории сервиса:

```shell
mvn spring-boot:run
```
Предполагается, что user-service запущен на `localhost:8081`, а 
order-service на `localhost:8082`

### Запуск через docker-compose

В корне проекта:

```commandline
docker-compose up --build
```

## Архитектура приложения

### user-service

#### Модель

Пользователь (`User`) представляет собой данные:

- Id (`Long id`)
- Имя (`String name`)
- Почта (`String email`)
- Дата создания (`Date creationDate`)

Структура пользователя для трансфера (`UserDTO`) представляет собой данные:

- Имя (`String name`)
- Почта (`String email`)

#### Репозиторий

- `UserRepository` - взаимодействие с базой данных через Spring Data JPA

#### Контроллер

- `UserController`
- - `GET /users/{userId}` - получение полной информации о пользователе по его id
- - `POST /users` - создание нового пользователя по `UserDTO` (и его возврат)
- - `DELETE /users/{userId}` - удаление пользователя по его id
- - `GET /users` - получения списка всех пользователей

Более подробное описание работы с приложением указано в [openapi.yaml](user-service/src/main/resources/static/openapi.yaml)

#### Сервис

- `UserService` - бизнес-логика (валидация, работа с БД)

#### Обработка ошибок

Сервис возвращает следующие HTTP-статусы при ошибках:

- `400 Bad Request` - при переданных невалидных данных
- `404 Not Found` - если пользователь не найден

#### Тесты

Написаны как юнит тесты на `UserService`, так и интеграционные на `UserController`



### order-service

#### Модель

Заказ (`Order`) представляет собой данные:

- Id (`Long id`)
- Имя (`String name`)
- Количество заказов/товаров (`Long count`)
- Id пользователя, которому принадлежит заказ (`Long userId`)
- Дата создания (`Date creationDate`)

Структура заказа для трансфера (`UserDTO`) представляет собой данные:

- Имя (`String name`)
- Количество заказов/товаров (`Long count`)

#### Репозиторий

- `OrderRepository` - взаимодействие с базой данных через Spring Data JPA

#### Контроллер

- `OrderController`
- - `GET /orders/order/{orderId}` - получение полной информации о заказе по его id
- - `GET /orders/all/{userId}` - сполучения списка всех заказов пользователя
- - `DELETE /orders/{orderId}` - удаление заказа по его id
- - `POST /orders/{userId}` - создание заказа по id пользователя и `OrderDTO`

Более подробное описание работы с приложением указано в [openapi.yaml](order-service/src/main/resources/static/openapi.yaml)

#### Клиент

Для передачи запросов от order-service к user-service используется `UserClient`

#### Сервис

- `OrderService` - бизнес-логика (валидация, работа с БД)

#### Обработка ошибок

Сервис возвращает следующие HTTP-статусы при ошибках:

- `400 Bad Request` - при переданных невалидных данных
- `404 Not Found` - если заказ не найден

#### Тесты

Написаны как юнит тесты на `OrderService`, так и интеграционные на `OrderController`


## Логика работы

### user-service

1) При создании пользователя валидируются имя (на пустоту) и почта,
при этом логика дублированных имени/почты не рассматривается. То есть,
теоретически могут быть 2 пользователя с одинаковыми именем и почтой,
но разными id. Возвращается информация пользователя.
2) При получении информации о пользователе валидируется id (на > 0), и выбрасывается
NotFoundException, если пользователь с таким id не был найден. В противном случае
возвращается информация о пользователе (id, имя, почта и время создания).
3) При получении списка пользователей, если пользователей нет, то возвращается
пустой список.
4) При удалении пользователя валидируется id (на > 0), и пользователь удаляется.
Если пользователя с переданным id не было в системе, то никакая ошибка не выбрасывается
(считаем, что этот пользователь удален).

### order-service

1) При создании заказа валидируется userId (на > 0 и существование пользователя в системе)
Дублирование заказов аналогично не рассматривается. Возвращается информация о заказе.
2) При получении заказа валидируется id (на > 0), и выбрасывается
NotFoundException, если заказ с таким id не был найден. В противном случае
возвращается информация о заказе.
3) При получении списка заказов пользователя валидируется userId. В случае, если
у пользователя нет заказов, возвращается пустой список.
4) При удалении заказа валидируется id (на > 0), и заказ удаляется.
Если заказа с переданным id не было в системе, то никакая ошибка не выбрасывается
(считаем, что этот заказ удален).

## Docker, Docker Compose

В каждом Dockerfile происходит отдельная сборка каждого сервиса и его запуск

В docker-compose собираем оба Dockerfile

## CI/CD

GitHub Actions:

- Автоматический запуск на push/pr

- Использование матричной стратегии (засчет чего избавляемся от дублирования кода и 
получаем параллельность выполнения назначенных задач)

- Этапы:

- - Сборка проекта

- - Запуск тестов

- - Сборка отдельных Docker-образов

- - Сборка docker-compose

## Возможные доработки/улучшения

1) Улучшение валидации параметров/событий
2) Улучшение качества тестирования
3) Дальнейшая реализация с PostgreSQL















